/// Filtering

/// Blur an image by a applying a (2dx+1)x(2dy+1) mean filter.
/// Each pixel is substituted by the mean of the pixels in the rectangle
/// [x-dx, x+dx]x[y-dy, y+dy].
/// The image is changed in-place.
void ImageBlur(Image img, int dx, int dy) {
  InstrReset();
  assert(img != NULL);
  assert(dx >= 0);
  assert(dy >= 0);

  Image img1 = ImageCreate(img->width, img->height, img->maxval);
  int x, y;
  int h = img->height;
  int w = img->width;
  double sum = 0.0;
  double count = 0.0;
  for (y = 0; y < h; y++) {
    for (x = 0; x < w; x++) {
      ADDITIONS += 1;
      sum = 0.0;
      count = 0.0;
      int i, j;
      for (j = y - dy; j <= y + dy; j++) {
        for (i = x - dx; i <= x + dx; i++) {
          ADDITIONS += 1;
          if (ImageValidPos(img, i, j)) {
            sum += (ImageGetPixel(img, i, j));
            count++;
          }
        }
      }
      ImageSetPixel(img1, x, y, (int)(sum / count + 0.5));
    }
  }
  for (y = 0; y < h; y++) {
    for (x = 0; x < w; x++) {
      ADDITIONS += 1;
      ImageSetPixel(img, x, y, ImageGetPixel(img1, x, y));
    }
  }
  free(img1);
  InstrPrint();
}

isto é a função blur a 17 novembro as 16:00

int ImageLocateSubImage(Image img1, int* px, int* py, Image img2) {
  assert(img1 != NULL);
  assert(img2 != NULL);

  
  if (img1->height < img2->height || img1->width < img2->width) {
    return 0;
  }

  int x, y;
  int h1 = img1->height;
  int w1 = img1->width;
  int h2 = img2->height;
  int w2 = img2->width;

  for (y = 0; y <= h1 - h2; y++) {
    for (x = 0; x <= w1 - w2; x++) {
      if (ImageMatchSubImage(img1, x, y, img2)) {
        *px = x;
        *py = y;
        return 1;
      }
    }
  }
  return 0;
}